---
title: "계층적 페이징 (Hierarchical Paging)"
description: "페이지 테이블 자체를 페이징하여 여러 단계로 나누는 기법"
tags: ["OS", "Memory", "Paging"]
created: 2026-01-27
updated: 2026-01-27
draft: false
slug: knowledge/os/hierarchical-paging
sidebar:
  order: 4
---

## 핵심 개념

계층적 페이징은 페이지 테이블 자체를 페이징하여 여러 단계로 나누는 기법입니다. 큰 주소 공간에서 단일 페이지 테이블은 너무 크기 때문에(32비트 주소, 4KB 페이지 → 2^20 엔트리 × 4B = 4MB/프로세스), 사용하지 않는 영역의 페이지 테이블까지 메모리에 유지하는 것은 낭비입니다.

## 동작 원리

페이지 테이블도 연속 메모리에 있을 필요 없으므로, 페이지 단위로 나누어 필요한 부분만 메모리에 유지합니다.

### 2단계 페이징 (32비트)

논리 주소: `[p1(10비트) | p2(10비트) | d(12비트)]`
- p1: 외부(outer) 페이지 테이블 인덱스
- p2: 내부(inner) 페이지 테이블 인덱스
- d: 페이지 오프셋
- **Forward-mapped page table**이라고도 함 (바깥→안쪽 방향)

```
논리 주소: [p1 | p2 | d]
            │
            v
   ┌─ 외부 페이지 테이블 ─┐
   │   [0] [1] [2] ...   │
   └────────┬────────────┘
            │ (p1 인덱스)
            v
   ┌─ 내부 페이지 테이블 ─┐
   │   [0] [1] [2] [3]   │
   └────────┬────────────┘
            │ (p2 인덱스)
            v
        프레임 번호
            │
            v
   물리 주소: [f | d]
```

### IA-32 (32비트) 페이지 테이블 구조

```
가상 주소 (32비트)
┌──────┬───────────┬───────────┬────────────┐
│ 2bit │   9bit    │   9bit    │   12bit    │
│ PDPT │   PDE     │   PTE     │  Offset    │
└──┬───┴─────┬─────┴─────┬─────┴──────┬─────┘
   │         │           │            │
   ▼         ▼           ▼            ▼
 PDPT → Page Dir → PTE Table → 4KB Page → 바이트
(4개)   (512개)    (512개)
```

주소 변환 과정:
1. 상위 2비트 → PDPT 인덱스 (4개 중 선택)
2. 다음 9비트 → Page Directory 인덱스 (512개 중 선택)
3. 다음 9비트 → PTE 인덱스 (512개 중 선택)
4. 하위 12비트 → 페이지 내 바이트 오프셋

### AMD64 (64비트) 페이지 테이블 구조

2단계로는 부족합니다(외부 테이블이 2^42 엔트리 = 16TB). x86-64는 4단계 페이징(48비트 가상 주소)을 사용합니다.

```
[unused(16)] | [PML4(9)] | [PDPT(9)] | [PD(9)] | [PT(9)] | [offset(12)]
    48비트 가상 주소, 4KB 페이지
```

### Self-Map (자기 참조)

페이지 디렉토리의 한 엔트리가 자기 자신을 가리키게 하여, 페이지 테이블 자체를 가상 주소로 접근 가능하게 합니다.

- IA-32: 8MB 가상 주소 공간 사용
- AMD64: 512GB 가상 주소 공간 사용

### 대안적 구조

- **해시 페이지 테이블**: 가상 페이지 번호를 해시하여 검색. 체이닝으로 충돌 해결.
- **역 페이지 테이블**: 물리 프레임당 하나의 엔트리. 시스템 전체에 하나. 메모리 절약, 검색 비용 증가.

## 예시

대형 도서관의 목록 체계와 같습니다. 1층 목록(분야) → 2층 목록(세부 주제) → 3층 목록(도서) → 실제 책. 필요한 분야의 목록만 펼쳐보면 됩니다.

32비트 2단계 시나리오:
- 논리 주소 = 0x00403004
- p1 = 1 (상위 10비트), p2 = 3 (중간 10비트), d = 4 (하위 12비트)
- 외부 테이블[1] → 내부 테이블 주소 획득 → 내부 테이블[3] → 프레임 번호 획득
- 물리 주소 = 프레임 번호 + 4

- 장점: 사용하지 않는 주소 영역의 페이지 테이블 메모리 절약, 페이지 테이블 자체도 스와핑 가능
- 단점: 단계가 늘어날수록 메모리 접근 횟수 증가 (n단계 → n+1회 접근), TLB 의존도 증가

## 관련 개념

- [논리 주소와 물리 주소](/knowledge/os/logical-physical-address/)
- [가상 메모리 (Virtual Memory)](/knowledge/os/virtual-memory/)
- [요구 페이징 (Demand Paging)](/knowledge/os/demand-paging/)
