---
title: "페이징 (Paging)"
description: "논리 메모리를 고정 크기의 페이지로, 물리 메모리를 같은 크기의 프레임으로 나누어 비연속적으로 할당하는 메모리 관리 기법"
tags: ["OS", "Memory"]
created: 2026-01-27
updated: 2026-01-27
draft: false
slug: knowledge/os/paging
sidebar:
  order: 13
---

## 핵심 개념

페이징은 논리 메모리를 **페이지(Page)**라는 고정 크기 블록으로, 물리 메모리를 같은 크기의 **프레임(Frame)**으로 나누는 방식이다. 마치 책(논리 메모리)의 각 페이지를 책장(물리 메모리)의 빈 칸 어디든 꽂아 넣을 수 있는 것처럼, 프로세스의 페이지들은 물리 메모리의 아무 프레임에나 배치될 수 있다.

- **페이지(Page)**: 논리 메모리의 고정 크기 블록
- **프레임(Frame)**: 물리 메모리의 고정 크기 블록 (페이지와 같은 크기)
- **프레임 테이블**: OS가 관리하며, 각 프레임의 할당 상태를 추적

## 동작 원리

CPU가 생성하는 논리 주소는 두 부분으로 나뉜다.

- **논리 주소**: `[페이지 번호(p) | 페이지 오프셋(d)]`
- **물리 주소**: `[프레임 번호(f) | 오프셋(d)]`

페이지 번호(p)로 **페이지 테이블**을 조회하여 프레임 번호(f)를 얻고, 오프셋(d)을 그대로 붙여 물리 주소를 구성한다.

```
논리 주소                        물리 주소
┌──────────┬──────────┐         ┌──────────┬──────────┐
│ 페이지(p) │ 오프셋(d) │         │ 프레임(f) │ 오프셋(d) │
└─────┬────┴──────────┘         └──────────┴──────────┘
      │                               ▲
      │     ┌──────────────┐          │
      └────►│ 페이지 테이블  │──────────┘
            │  p → f 매핑   │
            └──────────────┘
```

### 장점

- **외부 단편화 제거**: 프레임 단위로 할당하므로 외부에 자투리 공간이 생기지 않는다
- **비연속 배치**: 프로세스의 페이지들이 물리적으로 흩어져 있어도 된다
- **큰 논리 주소 공간**: 물리 메모리보다 큰 주소 공간을 논리적으로 사용할 수 있다

### 단점

- **내부 단편화**: 마지막 페이지는 꽉 차지 않을 수 있다 (평균 반 페이지 낭비)
- **페이지 테이블 오버헤드**: 페이지 테이블 자체가 메모리를 차지한다

## 예시

```
페이지 크기 = 4KB, 프로세스 크기 = 10KB

필요 페이지 수 = ⌈10KB / 4KB⌉ = 3페이지
마지막 페이지 내부 단편화 = 4KB × 3 - 10KB = 2KB

페이지 테이블:
  페이지 0 → 프레임 5
  페이지 1 → 프레임 2
  페이지 2 → 프레임 8  (2KB만 사용, 2KB 내부 단편화)

논리 주소 5000 변환:
  p = 5000 / 4096 = 1 (페이지 1)
  d = 5000 % 4096 = 904 (오프셋)
  프레임 = 2 (테이블 조회)
  물리 주소 = 2 × 4096 + 904 = 9096
```

## 관련 개념

- [페이지 테이블](/knowledge/os/page-table/)
- [연속 메모리 할당](/knowledge/os/contiguous-allocation/)
- [메모리 단편화](/knowledge/os/fragmentation/)
