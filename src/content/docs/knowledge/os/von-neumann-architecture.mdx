---
title: "폰 노이만 아키텍처 (Von Neumann Architecture)"
description: "메모리에서 명령어를 가져와 실행하는 명령어 실행 사이클을 따르는 컴퓨터 구조"
tags: ["OS", "Architecture", "CPU", "Memory"]
created: 2026-01-25
updated: 2026-01-25
draft: false
slug: knowledge/os/von-neumann-architecture
sidebar:
  order: 2
---

import StepFlow from '../../../../components/StepFlow.astro';

## 핵심 개념

폰 노이만 아키텍처는 메모리에서 명령어를 가져와 명령어 레지스터에 저장하고, 디코딩하여 피연산자를 가져와 실행한 후 결과를 메모리에 저장하는 명령어 실행 사이클을 따르는 컴퓨터 구조이다.

> CPU는 명령어를 메모리에서만 로드할 수 있다. 따라서 실행할 프로그램은 반드시 메모리에 있어야 한다.

## 명령어 실행 사이클

<StepFlow
  steps={[
    { label: "Fetch" },
    { label: "Store" },
    { label: "Decode" },
    { label: "Fetch operands" },
    { label: "Execute" },
    { label: "Store result" }
  ]}
  cycle={true}
/>

| 단계 | 동작 |
|------|------|
| **Fetch** | 메모리에서 명령어를 가져옴 |
| **Store** | 명령어를 명령어 레지스터(instruction register)에 저장 |
| **Decode** | 명령어를 디코딩 |
| **Fetch operands** | 피연산자를 메모리에서 가져와 내부 레지스터에 저장 |
| **Execute** | 피연산자에 대한 명령어 실행 |
| **Store result** | 결과를 메모리에 저장 |

## load와 store 명령어

모든 형태의 메모리는 바이트 배열을 제공하며, 각 바이트는 고유 주소를 가진다.

| 명령어 | 동작 |
|--------|------|
| **load** | 주 메모리에서 CPU 내부 레지스터로 바이트 또는 워드 이동 |
| **store** | 레지스터 내용을 주 메모리로 이동 |

명시적 load/store 외에도, CPU는 프로그램 카운터에 저장된 위치에서 실행할 명령어를 자동으로 로드한다.

## 메모리 단위의 관점

메모리 단위는 메모리 주소의 스트림만 보며, 다음을 알지 못한다:

- 주소가 어떻게 생성되었는지 (명령어 카운터, 인덱싱, 간접 참조 등)
- 주소가 무엇을 위한 것인지 (명령어인지 데이터인지)

## 메모리 관리 필요성

폰 노이만 아키텍처에서:
- CPU는 명령어 가져오기 사이클 동안 주 메모리에서 명령어를 읽음
- 데이터 가져오기 사이클 동안 주 메모리에서 데이터를 읽고 씀
- 주 메모리는 일반적으로 CPU가 직접 주소 지정하고 접근할 수 있는 유일한 대용량 저장 장치

> CPU가 디스크의 데이터를 처리하려면, 해당 데이터가 먼저 I/O 호출에 의해 주 메모리로 전송되어야 한다.

## 출처

- Operating System Concepts, 10th Edition, Chapter 1, p.12, 28
