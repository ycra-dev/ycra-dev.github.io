---
title: "VMM CPU 스케줄링 (VMM CPU Scheduling)"
description: "물리 CPU를 여러 가상 CPU(VCPU)에 할당하고 시분할하여 각 게스트가 전용 CPU를 가진 것처럼 느끼게 하는 VMM의 기능"
tags: ["OS", "Virtualization", "Scheduling"]
created: 2026-01-28
updated: 2026-01-28
draft: true
slug: knowledge/os/vmm-cpu-scheduling
sidebar:
  order: 13
---

## 핵심 개념

VMM CPU 스케줄링은 물리 CPU를 여러 **가상 CPU(VCPU)**에 할당하고 시분할하여, 각 게스트 OS가 자신만의 전용 CPU를 가진 것처럼 느끼게 하는 VMM의 기능이다.

게스트들은 자신이 전용 CPU를 가진다고 믿지만, 실제 물리 CPU는 제한적이다. 할당된 VCPU 총합이 물리 CPU 수를 초과하는 **오버커밋(overcommitment)** 상황이 흔하다.

## 동작 원리

### VCPU 스케줄링

1. 게스트 생성 시 VCPU 수를 설정 (예: 4개 VCPU)
2. VMM이 VCPU 스레드를 물리 CPU에 스케줄링
3. 물리 CPU가 충분하면 VCPU를 전용으로 할당 가능
4. 부족하면 오버커밋 → 시분할

```
┌─────────────────────────────────────────────────────┐
│                    VMM Scheduler                     │
│                                                     │
│  Guest 1 (4 VCPUs)    Guest 2 (4 VCPUs)             │
│  ┌──┬──┬──┬──┐       ┌──┬──┬──┬──┐                 │
│  │V0│V1│V2│V3│       │V0│V1│V2│V3│                 │
│  └──┴──┴──┴──┘       └──┴──┴──┴──┘                 │
│        │                   │                        │
│        └─────────┬─────────┘                        │
│                  │ 스케줄링                          │
│                  ↓                                  │
│  ┌──────────────────────────────────────────┐      │
│  │    Physical CPUs (6개)                    │      │
│  │  [CPU0] [CPU1] [CPU2] [CPU3] [CPU4] [CPU5]│      │
│  └──────────────────────────────────────────┘      │
└─────────────────────────────────────────────────────┘
```

### 오버커밋

할당된 VCPU 총합이 물리 CPU 수를 초과하는 상황이다. VMM은 표준 스케줄링 알고리즘(RR, Priority 등)에 공정성을 추가하여 각 게스트에 비례적 CPU 시간을 분배한다.

```
[6개 물리 CPU, 12개 VCPU 할당]

Guest 1: 4 VCPUs → 실제 2 물리 CPU 할당 (50%)
Guest 2: 4 VCPUs → 실제 2 물리 CPU 할당 (50%)
Guest 3: 4 VCPUs → 실제 2 물리 CPU 할당 (50%)

각 게스트는 4개 CPU가 있다고 믿지만,
실제로는 절반의 시간만 물리 CPU 사용
```

### 시간 왜곡 문제

게스트 OS의 타임 슬라이스가 예상대로 동작하지 않는다. 게스트가 100ms 타임 슬라이스를 설정해도, VMM이 중간에 다른 게스트로 스위칭하면 실제 경과 시간이 훨씬 길어진다.

```
[게스트 입장]
타이머 설정: 100ms 후 인터럽트

[실제 상황]
게스트가 50ms 실행 → VMM이 다른 게스트로 스위칭 (1초)
→ 다시 게스트 실행 → 50ms 후 타이머 만료
→ 실제 경과 시간: 1.1초 (100ms 아님!)
```

| 게스트 유형 | 영향 |
|------------|------|
| Time-sharing OS | 응답 시간 저하 |
| Real-time OS | **심각한 문제** (deadline 못 맞춤) |
| Database | 타임아웃 오동작 |

**해결책**: VMM이 게스트용 클럭 보정 애플리케이션을 제공하여 clock drift를 보정한다.

### VMM 자체의 CPU 사용

VMM도 게스트 관리, I/O 관리, 라이브 마이그레이션 등을 위해 CPU 시간이 필요하다. 게스트 CPU 시간 일부를 "훔쳐" 사용한다 (CPU steal).

## 예시

여러 팀이 회의실을 예약하여 사용하는 것에 비유할 수 있다. 각 팀은 예약된 시간에 회의실을 전용으로 사용한다고 느끼지만, 실제로는 시간대별로 공유한다.

### 장단점

- **장점**: 유연한 자원 할당 (오버커밋 가능), 물리 CPU보다 많은 VCPU 제공 가능, 공정한 자원 분배
- **단점**: 시간 왜곡으로 게스트 스케줄링 예측 불가, 실시간 워크로드에 부적합, 성능 변동성

## 관련 개념

- [CPU 스케줄링 (CPU Scheduling)](/knowledge/os/cpu-scheduling/) - 일반 OS의 CPU 스케줄링
- [VMM 메모리 관리](/knowledge/os/vmm-memory-management/) - VMM의 메모리 자원 관리
- [하이퍼바이저 유형 (Type 0/1/2)](/knowledge/os/hypervisor-types/) - 하이퍼바이저 분류
