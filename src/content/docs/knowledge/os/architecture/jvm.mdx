---
title: "JVM (Java Virtual Machine)"
description: "Java 바이트코드를 실행하는 추상 컴퓨터 명세로, 프로그래밍 환경 가상화의 대표적 사례"
tags: ["OS", "Virtualization", "Java"]
created: 2026-01-27
updated: 2026-01-27
draft: false
slug: knowledge/os/jvm
sidebar:
  order: 12
---

import LayerStack from '../../../../../components/LayerStack.astro';
import StepFlow from '../../../../../components/StepFlow.astro';
import NestedDiagram from '../../../../../components/NestedDiagram.astro';

## 핵심 개념

JVM(Java Virtual Machine)은 Java 바이트코드를 실행하는 **추상 컴퓨터 명세**로, **프로그래밍 환경 가상화(Programming-Environment Virtualization)** 의 대표적 사례이다. "Write Once, Run Anywhere" 목표를 실현하여 플랫폼 독립적인 프로그램 실행을 가능하게 한다.

비유하면, Java 바이트코드는 **세계 공용어**와 같다. 어떤 "나라"(OS)에서든 "통역사"(JVM)가 이해할 수 있다.

## 동작 원리

<StepFlow
  title="JVM 실행 흐름"
  steps={[
    { label: "Java Program", description: ".java 소스 파일" },
    { label: "Compile", description: "javac 컴파일러" },
    { label: "Bytecode", description: ".class 파일" },
    { label: "Class Loader", description: ".class + Java API 로드" },
    { label: "Verifier", description: "바이트코드 유효성 검증" },
    { label: "Interpreter/JIT", description: "네이티브 코드 실행" }
  ]}
/>

<LayerStack
  title="JVM 내부 구조"
  layers={[
    { label: "Java Interpreter / JIT", description: "바이트코드 → 네이티브 명령어 실행" },
    { label: "Garbage Collector", description: "미사용 객체 메모리 자동 회수" },
    { label: "Verifier", description: "스택 오버플로우, 불법 메모리 접근 방지" },
    { label: "Class Loader", description: ".class 파일 로드 + Java API 로드", highlight: true }
  ]}
/>

### JVM 구현 방식

| 방식 | 설명 | 성능 |
|------|------|------|
| **소프트웨어 인터프리터** | 바이트코드를 하나씩 해석 실행 | 느림 |
| **JIT 컴파일러** | 메서드 최초 호출 시 네이티브 코드로 컴파일, 캐싱 | 빠름 (현대 JVM 표준) |
| **하드웨어 구현** | Java 칩이 바이트코드 직접 실행 | 가장 빠름 (특수 HW 필요) |

### 하드웨어 가상화 vs 프로그래밍 환경 가상화

| 특성 | 하드웨어 가상화 (VM) | 프로그래밍 환경 가상화 (JVM) |
|------|---------------------|---------------------------|
| 가상화 대상 | CPU, 메모리, I/O | 프로그래밍 API, 런타임 |
| 목적 | 전체 OS 실행 | 특정 언어 프로그램 실행 |
| 게스트 | 운영체제 | Java 프로그램 |
| 예시 | VMware, VirtualBox | JVM, .NET CLR |

### 보안 기능

- **Verifier**: 바이트코드가 안전한지 실행 전 검증
- **포인터 연산 금지**: 불법 메모리 접근 원천 차단
- **스택 검사**: 오버플로우/언더플로우 방지
- **Sandbox**: 신뢰되지 않은 코드의 시스템 접근 제한

## 예시

<NestedDiagram
  title="기존 방식 vs Java 방식"
  items={[
    {
      label: "기존 방식 (C 프로그램)",
      children: [
        { label: "Windows 컴파일" },
        { label: "Linux 컴파일" },
        { label: "macOS 컴파일" }
      ]
    },
    {
      label: "Java 방식",
      highlight: true,
      children: [
        { label: "바이트코드 (.class)", highlight: true },
        { label: "JVM (Windows)" },
        { label: "JVM (Linux)" },
        { label: "JVM (macOS)" }
      ]
    }
  ]}
/>

Java의 플랫폼 독립성: 바이트코드를 한 번만 생성하면 각 OS의 JVM이 실행한다.
