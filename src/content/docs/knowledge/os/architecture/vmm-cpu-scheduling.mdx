---
title: "VMM CPU 스케줄링 (VMM CPU Scheduling)"
description: "물리 CPU를 여러 가상 CPU(VCPU)에 할당하고 시분할하여 각 게스트가 전용 CPU를 가진 것처럼 느끼게 하는 VMM의 기능"
tags: ["OS", "Virtualization", "Scheduling"]
created: 2026-01-28
updated: 2026-01-28
draft: false
slug: knowledge/os/vmm-cpu-scheduling
sidebar:
  order: 8
---

import ArchitectureStack from '../../../../../components/ArchitectureStack.astro';
import StepFlow from '../../../../../components/StepFlow.astro';
import LayerStack from '../../../../../components/LayerStack.astro';

## 핵심 개념

VMM CPU 스케줄링은 물리 CPU를 여러 **가상 CPU(VCPU)** 에 할당하고 시분할하여, 각 게스트 OS가 자신만의 전용 CPU를 가진 것처럼 느끼게 하는 VMM의 기능이다.

게스트들은 자신이 전용 CPU를 가진다고 믿지만, 실제 물리 CPU는 제한적이다. 할당된 VCPU 총합이 물리 CPU 수를 초과하는 **오버커밋(overcommitment)** 상황이 흔하다.

## 동작 원리

### VCPU 스케줄링

<StepFlow
  title="VCPU 스케줄링 흐름"
  steps={[
    { label: "게스트 생성", description: "VCPU 수 설정 (예: 4개)" },
    { label: "VCPU 스레드 생성", description: "VMM이 각 VCPU를 스레드로 관리" },
    { label: "물리 CPU 할당", description: "충분하면 전용, 부족하면 시분할" },
    { label: "스케줄링", description: "VMM Scheduler가 VCPU ↔ 물리 CPU 매핑" }
  ]}
/>

<div style="max-width: 500px; margin: 0 auto;">
<ArchitectureStack
  title="VMM 스케줄링 구조"
  topItems={[
    { label: "Guest 1", description: "4 VCPUs (V0-V3)" },
    { label: "Guest 2", description: "4 VCPUs (V0-V3)" }
  ]}
  baseLayer={{ label: "Physical CPUs (6개)", description: "VMM Scheduler가 VCPU를 물리 CPU에 매핑", highlight: true }}
/>
</div>

### 오버커밋

할당된 VCPU 총합이 물리 CPU 수를 초과하는 상황이다. VMM은 표준 스케줄링 알고리즘(RR, Priority 등)에 공정성을 추가하여 각 게스트에 비례적 CPU 시간을 분배한다.

| 상황 | 물리 CPU | 총 VCPU | 결과 |
|------|----------|---------|------|
| **예시** | 6개 | 12개 (3 게스트 × 4 VCPU) | 각 게스트 50% 시간만 사용 |

각 게스트는 4개 CPU가 있다고 믿지만, 실제로는 절반의 시간만 물리 CPU를 사용한다.

### 시간 왜곡 문제

게스트 OS의 타임 슬라이스가 예상대로 동작하지 않는다. 게스트가 100ms 타임 슬라이스를 설정해도, VMM이 중간에 다른 게스트로 스위칭하면 실제 경과 시간이 훨씬 길어진다.

<StepFlow
  title="시간 왜곡 예시"
  steps={[
    { label: "타이머 설정", description: "100ms 후 인터럽트" },
    { label: "50ms 실행", description: "게스트 실행 중" },
    { label: "VMM 스위칭", description: "다른 게스트로 1초간 전환" },
    { label: "50ms 재개", description: "타이머 만료" },
    { label: "실제 경과", description: "1.1초 (100ms 아님!)" }
  ]}
/>

| 게스트 유형 | 영향 |
|------------|------|
| Time-sharing OS | 응답 시간 저하 |
| Real-time OS | **심각한 문제** (deadline 못 맞춤) |
| Database | 타임아웃 오동작 |

**해결책**: VMM이 게스트용 클럭 보정 애플리케이션을 제공하여 clock drift를 보정한다.

### VMM 자체의 CPU 사용

VMM도 게스트 관리, I/O 관리, 라이브 마이그레이션 등을 위해 CPU 시간이 필요하다. 게스트 CPU 시간 일부를 "훔쳐" 사용한다 (CPU steal).

## 예시

여러 팀이 회의실을 예약하여 사용하는 것에 비유할 수 있다. 각 팀은 예약된 시간에 회의실을 전용으로 사용한다고 느끼지만, 실제로는 시간대별로 공유한다.

### 장단점

| 구분 | 내용 |
|------|------|
| **장점** | 유연한 자원 할당 (오버커밋 가능), 물리 CPU보다 많은 VCPU 제공, 공정한 자원 분배 |
| **단점** | 시간 왜곡으로 게스트 스케줄링 예측 불가, 실시간 워크로드에 부적합, 성능 변동성 |
