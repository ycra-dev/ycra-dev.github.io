---
title: "저장장치 초기화 (Storage Initialization)"
description: "새 저장장치를 사용하기 위한 포매팅, 파티셔닝, 볼륨 생성 과정"
tags: ["OS", "Storage"]
created: 2026-01-27
updated: 2026-02-11
draft: false
slug: knowledge/os/storage-initialization
sidebar:
  order: 17
---

import StepFlow from '../../../../../components/StepFlow.astro';
import NestedDiagram from '../../../../../components/NestedDiagram.astro';

## 핵심 개념

새 저장장치를 운영체제에서 사용하려면 여러 단계의 초기화 과정이 필요하다. 공장에서 만들어진 빈 디스크가 파일을 저장할 수 있게 되기까지, **저수준 포매팅 → 파티셔닝 → 볼륨 생성 → 논리적 포매팅** 순서로 진행된다.

쉽게 비유하면: 빈 공책(디스크)에 줄을 긋고(저수준 포매팅), 섹션을 나누고(파티셔닝), 목차를 만드는(논리적 포매팅) 과정이다.

## 동작 원리

### 단계별 과정

<StepFlow
  title="저장장치 초기화 순서"
  steps={[
    { label: "저수준 포매팅", description: "공장에서 섹터/페이지 구조 생성" },
    { label: "파티셔닝", description: "디스크를 논리적 그룹으로 분할" },
    { label: "볼륨 생성", description: "파티션을 볼륨으로 구성" },
    { label: "논리적 포매팅 (mkfs)", description: "파일 시스템 메타데이터 기록" },
  ]}
/>

### 1단계: 저수준 포매팅 (Physical Formatting)

공장에서 수행하는 과정으로, 디스크 표면에 **섹터/페이지 구조**를 생성한다.

<div style="max-width: 480px; margin: 0 auto;">
<NestedDiagram
  title="하나의 섹터 구조"
  items={[
    { label: "헤더", children: [{ label: "섹터 번호" }, { label: "동기화 정보" }] },
    { label: "데이터 영역", highlight: true, children: [{ label: "512B 또는 4KB", highlight: true }] },
    { label: "ECC 트레일러", children: [{ label: "오류 정정 코드" }] },
  ]}
/>
</div>

### 2단계: 파티셔닝

디스크를 **논리적 그룹(파티션)**으로 분할한다.

| 방식 | 파티션 수 | 최대 디스크 크기 | 특징 |
|------|-----------|-----------------|------|
| **MBR** | 4개 (주 파티션) | 최대 2TB | 레거시, BIOS |
| **GPT** | 128개 | 2TB 이상 (최대 9.4ZB) | UEFI, 백업 헤더 존재 |

MBR은 디스크 첫 섹터에 파티션 테이블을 저장한다. GPT는 디스크 시작과 끝에 중복 저장하여 안전성이 높다.

### 3단계: 볼륨 생성

파티션을 **볼륨(Volume)**으로 구성한다. 단순히 파티션 하나가 볼륨이 될 수도 있고, 여러 파티션이나 디스크를 합쳐 하나의 볼륨을 만들 수도 있다.

- **LVM (Logical Volume Manager)**: 여러 물리 디스크를 하나의 논리 볼륨으로 통합, 동적 크기 조절 가능
- **RAID**: 여러 디스크를 묶어 성능 또는 안정성 향상
- **ZFS**: 볼륨 관리와 파일 시스템을 통합한 방식

### 4단계: 논리적 포매팅 (mkfs)

볼륨에 **파일 시스템 메타데이터 구조**를 기록한다.

<div style="max-width: 480px; margin: 0 auto;">
<NestedDiagram
  title="파일 시스템 메타데이터 구조"
  items={[
    { label: "수퍼블록", children: [{ label: "FS 정보" }] },
    { label: "inode 테이블", children: [{ label: "파일 메타" }] },
    { label: "데이터 블록", highlight: true, children: [{ label: "비트맵", highlight: true }] },
    { label: "저널 영역", children: [{ label: "ext3/4" }] },
  ]}
/>
</div>

### Raw I/O

파일 시스템 없이 **직접 블록 수준으로 접근**하는 방식이다. DBMS(Oracle, MySQL 등)에서 자체적으로 데이터를 관리할 때 활용한다. 파일 시스템 오버헤드를 제거하여 성능을 높일 수 있지만, OS의 파일 시스템 기능(캐싱, 저널링 등)을 사용할 수 없다.

## 예시

Linux에서 새 디스크 초기화 과정:

```bash
# 1. 디스크 확인
lsblk
# /dev/sdb  100G  (새 디스크)

# 2. 파티셔닝 (GPT 방식)
sudo parted /dev/sdb mklabel gpt
sudo parted /dev/sdb mkpart primary 0% 100%

# 3. 논리적 포매팅 (ext4 파일 시스템)
sudo mkfs.ext4 /dev/sdb1

# 4. 마운트
sudo mount /dev/sdb1 /mnt/data

# 영구 마운트 (/etc/fstab에 추가)
echo '/dev/sdb1 /mnt/data ext4 defaults 0 2' | sudo tee -a /etc/fstab
```
