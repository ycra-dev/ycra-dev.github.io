---
title: "오류 검출과 정정 (ECC)"
description: "데이터 전송 및 저장 과정에서 발생하는 오류를 검출하고 정정하는 기법"
tags: ["OS", "Storage", "Reliability"]
created: 2026-01-27
updated: 2026-02-11
draft: false
slug: knowledge/os/ecc
sidebar:
  order: 5
---

import StepFlow from '../../../../../components/StepFlow.astro';

## 핵심 개념

오류 검출과 정정(Error-Correcting Code, ECC)은 데이터가 저장되거나 전송되는 과정에서 발생하는 **비트 오류를 발견하고 고치는 기법**이다. 디스크, 메모리, 네트워크 등 모든 데이터 경로에서 오류는 불가피하므로, 이를 자동으로 처리하는 메커니즘이 필수적이다.

## 동작 원리

### 오류 검출 기법

| 기법 | 원리 | 능력 | 사용처 |
|------|------|------|--------|
| **패리티 비트** | XOR 연산으로 1의 개수를 짝수/홀수로 맞춤 | 단일 비트 오류 검출, 2비트 오류 미검출 | 메모리, 직렬 통신 |
| **체크섬** | 데이터를 블록 단위로 더한 후 모듈러 연산 | 단순 오류 검출 | IP/TCP 헤더 |
| **CRC (Cyclic Redundancy Check)** | 다항식 나눗셈의 나머지를 검증 값으로 사용 | 다중/버스트 오류 검출 가능 | 이더넷, HDD, USB |

### 오류 정정 기법

오류 검출은 "틀렸다"를 알려주지만, 오류 정정은 "어디가 틀렸고 원래 값은 무엇인지"까지 알려준다.

| 기법 | 능력 | 사용처 |
|------|------|--------|
| **해밍 코드 (Hamming Code)** | 단일 비트 오류 정정 (SEC), 이중 비트 오류 검출 (DED) | ECC 메모리 |
| **Reed-Solomon 코드** | 다중 비트/바이트 오류 정정 | CD/DVD, QR 코드, SSD |
| **LDPC (Low-Density Parity-Check)** | 높은 비트 에러율에서도 강력한 정정 | SSD(NAND Flash), 5G |

### 저장장치별 ECC 적용

- **HDD**: 각 섹터(512B 또는 4KB)에 ECC 트레일러를 붙여 저장. 읽을 때마다 ECC 검증.
- **SSD**: 각 페이지(4~16KB) 단위로 ECC 적용. NAND Flash는 HDD보다 비트 에러율이 높아 더 강력한 ECC(LDPC, BCH) 사용.
- **ECC 메모리**: 64비트 데이터 + 8비트 ECC = 72비트. 단일 비트 오류 자동 정정, 이중 비트 오류 검출.

### 소프트 에러 vs 하드 에러

| 구분 | 원인 | ECC 처리 | 복구 방법 |
|------|------|----------|-----------|
| **소프트 에러** | 우주선, 전기적 노이즈 등 일시적 원인 | 정정 가능 | ECC가 자동 복구 |
| **하드 에러** | 물리적 손상 (미디어 결함) | 정정 불가 | 배드 블록 처리, RAID로 복구 |

소프트 에러는 다시 읽으면 정상이지만, 하드 에러는 해당 위치가 영구적으로 손상된 것이다.

## 예시

### 해밍(7,4) 코드로 단일 비트 오류 정정하기

원본 데이터 `1011`을 해밍 코드로 인코딩하고, 전송 중 오류가 발생했을 때 정정하는 과정이다.

<StepFlow
  title="해밍 코드 오류 정정 흐름"
  steps={[
    { label: "인코딩", description: "데이터 4비트 + 패리티 3비트 = 7비트" },
    { label: "전송 중 오류 발생", description: "5번 비트가 0→1로 뒤집힘" },
    { label: "신드롬 계산", description: "패리티 체크로 오류 위치 특정" },
    { label: "비트 반전으로 정정", description: "5번 비트를 뒤집어 복원" },
  ]}
/>

**1단계 — 인코딩**

위치 1, 2, 4는 패리티 비트(P)이고, 나머지에 데이터를 배치한다.

| 위치 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
|------|---|---|---|---|---|---|---|
| 역할 | P1 | P2 | **d1** | P4 | **d2** | **d3** | **d4** |
| 값 | 0 | 1 | **1** | 0 | **0** | **1** | **1** |

각 패리티 비트는 자신이 담당하는 위치들의 XOR로 계산한다.
- P1 (위치 1,3,5,7): `1⊕0⊕1` = **0**
- P2 (위치 2,3,6,7): `1⊕1⊕1` = **1**
- P4 (위치 4,5,6,7): `0⊕1⊕1` = **0**

전송 데이터: `0 1 1 0 0 1 1`

**2단계 — 오류 발생**

5번 비트에 오류: `0 1 1 0 [1] 1 1`

**3단계 — 신드롬(Syndrome) 계산**

수신 측에서 동일한 패리티 체크를 수행한다. 결과가 0이면 정상, 1이면 해당 그룹에 오류가 있다는 뜻이다.

| 체크 | 대상 위치 | XOR 결과 | 판정 |
|------|-----------|----------|------|
| S1 | 1,3,5,7 → `0⊕1⊕1⊕1` | **1** | 오류 |
| S2 | 2,3,6,7 → `1⊕1⊕1⊕1` | **0** | 정상 |
| S4 | 4,5,6,7 → `0⊕1⊕1⊕1` | **1** | 오류 |

오류 위치 = S4×4 + S2×2 + S1×1 = 1×4 + 0×2 + 1×1 = **5**

**4단계 — 정정**: 5번 비트를 반전 (`1→0`)하면 원래 데이터 복원 완료.
