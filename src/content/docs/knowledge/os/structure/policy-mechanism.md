---
title: 정책과 메커니즘 (Policy and Mechanism)
description: 메커니즘은 '어떻게' 수행할지, 정책은 '무엇을' 수행할지 결정하는 분리된 설계 원칙
tags: ["OS", "Policy", "Mechanism", "Design"]
created: 2026-01-25
updated: 2026-01-25
draft: false
slug: knowledge/os/policy-mechanism
sidebar:
  order: 8
---

## 핵심 개념

운영체제 설계에서 **메커니즘**(mechanism)은 "어떻게(how)" 수행할지를, **정책**(policy)은 "무엇을(what)" 수행할지를 결정한다. 이 둘을 분리하는 것이 유연한 시스템 설계의 핵심 원칙이다.

## 정책과 메커니즘의 구분

| 구분 | 정의 | 타이머 예시 |
|------|------|-------------|
| **메커니즘** | 어떻게 수행할지 결정 | 타이머 구조 자체 (CPU 보호를 위한 메커니즘) |
| **정책** | 무엇을 수행할지 결정 | 특정 사용자에 대해 타이머를 얼마나 설정할지 |

## 분리의 이점

**유연성 확보**가 핵심이다. 정책은 장소나 시간에 따라 변할 가능성이 높기 때문에:

- 범용적인 메커니즘이 있으면 정책 변경 시 시스템의 특정 파라미터만 재정의하면 됨
- 예: 프로그램 우선순위 메커니즘이 정책과 분리되어 있으면
  - I/O 집약적 프로그램에 우선순위를 주는 정책, 또는
  - CPU 집약적 프로그램에 우선순위를 주는 정책 모두 지원 가능

## 운영체제별 접근 방식

| 운영체제 | 접근 방식 |
|----------|----------|
| **Windows/macOS/iOS** | 정책과 메커니즘을 시스템에 밀접하게 인코딩. 전역적 외관과 느낌(global look and feel) 강제 |
| **Linux** | 표준 커널에 특정 CPU 스케줄링 알고리즘(메커니즘)이 있지만, 누구나 다른 정책을 지원하도록 스케줄러 수정/교체 가능 |

## 마이크로커널과의 관계

마이크로커널 기반 운영체제는 정책/메커니즘 분리를 극단적으로 적용한다:
- 기본적인 빌딩 블록만 구현하고, 거의 정책 없음(policy free)
- 더 고급 메커니즘과 정책은 사용자 생성 커널 모듈이나 사용자 프로그램으로 추가

## 트레이드오프

| 접근 방식 | 장점 | 단점 |
|-----------|------|------|
| **분리** | 유연성, 다양한 정책 지원 가능, 유지보수 용이 | 설계 복잡성 증가 |
| **결합** | 일관된 사용자 경험, 구현 단순화 | 유연성 감소, 정책 변경 어려움 |

## 출처

- Operating System Concepts, 10th Edition, Chapter 2, p.80
