---
title: 마이크로커널 (Microkernel)
description: 커널에서 비필수적인 구성 요소를 제거하고 사용자 수준 프로그램으로 구현하는 운영체제 구조
tags: ["OS", "Microkernel", "Mach", "QNX", "RC4000", "Message Passing"]
created: 2026-01-25
updated: 2026-01-27
draft: true
slug: knowledge/os/microkernel
sidebar:
  order: 3
---

import LayerStack from '../../../../../components/LayerStack.astro';
import StepFlow from '../../../../../components/StepFlow.astro';

## 핵심 개념

커널에서 **비필수적인 모든 구성 요소를 제거**하고, **사용자 수준 프로그램**으로 구현하여 별도의 주소 공간에 두는 운영체제 구조이다. 1960년대 후반 덴마크의 RC 4000에서 "운영체제 nucleus(핵)" 개념이 처음 제시되었고, 1980년대 중반 Carnegie Mellon 대학에서 Mach 운영체제로 본격 발전했다.

## 마이크로커널 구조

<LayerStack
  title="사용자 모드 ↔ 커널 모드"
  layers={[
    { label: "애플리케이션", description: "사용자 모드" },
    { label: "파일 시스템", description: "사용자 모드" },
    { label: "장치 드라이버", description: "사용자 모드" },
    { label: "마이크로커널", description: "커널 모드 (IPC)", highlight: true },
    { label: "하드웨어", description: "물리적 장치" }
  ]}
/>

## 커널에 남는 최소 기능

- 최소한의 프로세스 관리
- 최소한의 메모리 관리
- 통신 기능 (메시지 패싱)

## 통신 방식

클라이언트 프로그램과 서비스는 **직접 상호작용하지 않고**, 마이크로커널과 메시지를 교환하여 간접적으로 통신한다:
- 예: 파일 접근 시 클라이언트가 파일 서버와 마이크로커널을 통해 메시지 교환
- I/O 장치도 프로세스로 취급하여, 터미널 출력 시 터미널 프로세스에 메시지 전송

## RC 4000: 마이크로커널의 기원

1960년대 후반 덴마크에서 개발된 RC 4000은 최소한의 커널(nucleus) 위에 다양한 운영체제를 구축할 수 있는 범용 기반을 제시했다.

- 커널이 동시 프로세스 집합 지원
- 라운드-로빈 CPU 스케줄러
- 8워드 고정 크기 메시지, 공통 버퍼 풀에서 관리

### 메시지 프리미티브

```
send-message(receiver, message, buffer)    // 메시지 전송
wait-message(sender, message, buffer)      // 메시지 대기
send-answer(result, message, buffer)       // 응답 전송
wait-answer(result, message, buffer)       // 응답 대기
wait-event(prev-buffer, next-buffer, result)  // 이벤트 대기
get-event(buffer)                          // 이벤트 조회
```

## Mach 마이크로커널

| 버전 | 특징 |
|------|------|
| Release 0~2 | BSD 코드 커널 내부에 포함, 커널 크기 큼 |
| **Mach 3** | BSD 코드를 커널 밖으로 이동 → 진정한 마이크로커널 |

### Mach 3의 설계 목표

1. 4.3 BSD UNIX 에뮬레이션 (바이너리 호환)
2. 다양한 메모리 모델, 병렬/분산 컴퓨팅 지원
3. 4.3 BSD보다 단순하고 수정 용이한 커널

### 주요 특징

- **경량 프로세스(lightweight process)**: 하나의 task 내 다중 스레드
- 메시지를 유일한 통신 수단으로 사용
- 가상 메모리 시스템이 메시지를 통해 백킹 스토어 데몬과 통신

### Mach의 현재

- **GNU HURD**: 순수 Mach 구현 (거의 사용되지 않음)
- **XNU**: macOS와 iOS의 커널. Apple이 NeXT 인수 시 획득. Mach 코어 + BSD API 상위 레이어 구조

## 실제 예시

| 운영체제 | 설명 |
|----------|------|
| **Darwin** | macOS와 iOS의 커널 환경. Mach 마이크로커널 포함 |
| **QNX** | 임베디드 시스템용 실시간 운영체제. Neutrino 마이크로커널이 메시지 패싱, 프로세스 스케줄링, 저수준 네트워크 통신, 하드웨어 인터럽트 처리 |

## Windows NT 역사

<StepFlow
  steps={[
    { label: "첫 번째 릴리스", description: "계층적 마이크로커널 구조, Windows 95보다 낮은 성능" },
    { label: "Windows NT 4.0", description: "사용자 공간 계층을 커널 공간으로 이동, 부분적 성능 개선" },
    { label: "Windows XP", description: "마이크로커널보다 모놀리식에 가깝게 변화" }
  ]}
/>

## 트레이드오프

| 장점 | 단점 |
|------|------|
| 운영체제 확장 용이 (새 서비스가 사용자 공간에 추가) | 시스템 함수 오버헤드 증가로 성능 저하 |
| 커널 수정 시에도 변경 범위 작음 | 메시지 복사 (별도 주소 공간 간) |
| 한 하드웨어에서 다른 하드웨어로 이식 용이 | 프로세스 전환 필요 |
| 보안 및 신뢰성 향상 (서비스 실패 시 나머지 영향 없음) | 마이크로커널 성장의 가장 큰 장애물 |

## 출처

- Operating System Concepts, 10th Edition, Chapter 2, p.84-86
- Operating System Concepts, 10th Edition, Appendix A, p.A-11~A-12, A-16~A-18
