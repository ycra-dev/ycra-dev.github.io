---
title: "사용자 스레드 vs 커널 스레드"
description: "사용자 공간 라이브러리가 관리하는 사용자 스레드와 커널이 직접 관리하는 커널 스레드의 비교"
tags: ["OS", "Thread", "Concurrency"]
created: 2026-01-27
updated: 2026-01-27
draft: true
slug: knowledge/os/user-kernel-thread
sidebar:
  order: 12
---

## 핵심 개념

사용자 스레드는 커널 위에서 사용자 공간의 라이브러리가 관리하고, 커널 스레드는 운영체제 커널이 직접 지원하고 관리합니다. 스레드 관리 방식에 따라 성능, 기능, 이식성이 달라지므로, 어느 수준에서 스레드를 관리할지 결정해야 합니다.

## 동작 원리

### 사용자 스레드 (User Thread)

- **커널 위에서** 라이브러리에 의해 관리
- 커널은 사용자 스레드의 존재를 **모름**
- 스레드 연산(생성, 스케줄링)이 **시스템 콜 없이** 사용자 공간에서 처리

### 커널 스레드 (Kernel Thread)

- **운영체제 커널이 직접** 지원하고 관리
- 커널이 각 스레드를 **인식**하고 스케줄링
- 현대 OS(Windows, Linux, macOS) 모두 커널 스레드 지원

```
┌─────────────────────────────────────────┐
│              User Space                  │
│  ┌─────────────────────────────────┐    │
│  │    User Threads (T1, T2, T3)    │    │
│  │    ↓ 사용자 라이브러리 관리       │    │
│  └─────────────────────────────────┘    │
├─────────────────────────────────────────┤
│              Kernel Space                │
│  ┌─────────────────────────────────┐    │
│  │   Kernel Threads (K1, K2, ...)  │    │
│  │   ↓ 커널이 직접 스케줄링          │    │
│  └─────────────────────────────────┘    │
│               ↓                          │
│        Physical CPUs                     │
└─────────────────────────────────────────┘
```

### 비교

| 구분 | 사용자 스레드 | 커널 스레드 |
|------|---------------|-------------|
| 관리 주체 | 사용자 공간 라이브러리 | 커널 |
| 커널 인식 | 모름 | 알고 있음 |
| 생성/전환 비용 | 낮음 (시스템 콜 불필요) | 높음 (시스템 콜 필요) |
| 블로킹 시 | 전체 프로세스 블로킹 가능 | 해당 스레드만 블로킹 |
| 멀티코어 활용 | 불가 (커널이 모르므로) | 가능 |
| 예시 | Green Threads, 초기 Java 스레드 | Linux threads, Windows threads |

### 실제 시스템

- **Windows**: 커널 스레드 지원, One-to-One 모델
- **Linux**: 커널 스레드 지원, One-to-One 모델
- **macOS**: 커널 스레드 지원 (Pthreads 기반)
- **JVM**: 호스트 OS의 스레드 모델 사용

## 예시

- **사용자 스레드**: 한 회사 내 팀장이 팀원들의 업무를 배분 (본사 인사팀은 팀원 개개인을 모름)
- **커널 스레드**: 본사 인사팀이 모든 직원을 직접 관리하고 업무 배정

## 관련 개념

- [스레드 (Thread)](/knowledge/os/thread/)
- [멀티스레딩 모델](/knowledge/os/multithreading-models/)
- [프로세스 (Process)](/knowledge/os/process/)
