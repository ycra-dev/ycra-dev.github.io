---
title: "Interrupt-Driven I/O"
description: "장치가 준비되면 CPU에 인터럽트 신호를 보내 I/O 완료를 알리는 방식"
tags: ["OS", "I/O", "Interrupt"]
created: 2026-01-23
updated: 2026-01-27
slug: knowledge/os/interrupt-driven-io
sidebar:
  order: 2
---

import StepFlow from '../../../../../components/StepFlow.astro';

## 핵심 개념

장치가 준비되면 CPU에 인터럽트 신호를 보내 I/O 완료를 알리는 방식이다. 폴링 방식과 달리 CPU가 장치 상태를 계속 확인할 필요 없이, 장치가 능동적으로 CPU에 알림을 보낸다.

## 동작 원리

<StepFlow
  title="Interrupt-Driven I/O 흐름"
  steps={[
    { label: "I/O 시작", description: "디바이스 드라이버가 I/O 시작 명령을 컨트롤러에 전달" },
    { label: "CPU 병행 작업", description: "CPU는 다른 작업 수행 (I/O와 연산 병행)" },
    { label: "인터럽트 발생", description: "컨트롤러가 I/O 완료 시 interrupt-request line에 신호 발생" },
    { label: "인터럽트 감지", description: "CPU가 인터럽트 감지 → 현재 상태 저장 → 인터럽트 핸들러로 점프" },
    { label: "서비스 및 복원", description: "핸들러가 장치 서비스 (데이터 읽기, 인터럽트 클리어) 후 → 상태 복원 → 원래 작업 재개" }
  ]}
/>

## 예시

### 키보드 입력

사용자가 키를 누를 때마다 키보드 컨트롤러가 인터럽트 발생. CPU는 인터럽트를 받아 키 데이터를 읽는다.

## 장단점

### 장점

- CPU가 I/O 대기 중 다른 작업 가능 → CPU 활용도 향상
- 장치가 느려도 CPU 낭비 없음
- 비동기 이벤트 처리에 적합

### 단점

- 인터럽트 처리 오버헤드 (상태 저장/복원, 컨텍스트 스위치)
- 초당 수십만 개 인터럽트 처리 시 오버헤드 누적
- 고처리량 I/O에서는 폴링이 더 효율적일 수 있음
