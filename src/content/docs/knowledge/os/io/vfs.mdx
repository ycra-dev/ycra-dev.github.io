---
title: "VFS (Virtual File System)"
description: "다양한 파일 시스템을 단일 인터페이스로 추상화하여 애플리케이션이 파일 시스템 종류와 무관하게 동일한 시스템 콜을 사용할 수 있게 하는 계층"
tags: ["OS", "FileSystem", "Linux"]
created: 2026-01-28
updated: 2026-01-28
draft: false
slug: knowledge/os/vfs
sidebar:
  order: 12
---

import LayerStack from '../../../../../components/LayerStack.astro';
import ArchitectureStack from '../../../../../components/ArchitectureStack.astro';
import NestedDiagram from '../../../../../components/NestedDiagram.astro';
import StepFlow from '../../../../../components/StepFlow.astro';

## 핵심 개념

VFS(Virtual File System)는 ext4, NFS, FAT32, /proc 등 **다양한 파일 시스템을 단일 인터페이스로 추상화**하는 계층이다. 애플리케이션은 파일 시스템 종류와 무관하게 동일한 `open()`, `read()`, `write()` 시스템 콜을 사용할 수 있다.

UNIX 철학에서 "모든 것은 파일"이다. 디스크 파일뿐 아니라 디바이스, 네트워크, 프로세스 정보까지 파일처럼 다루려면 이러한 공통 추상화 계층이 필요하다.

## 동작 원리

### 4가지 핵심 객체 타입

VFS는 모든 파일 시스템을 4가지 객체 타입으로 추상화한다.

| 객체 | 설명 | 주요 연산 |
|------|------|----------|
| **inode** | 개별 파일의 메타데이터 | create, link, unlink, mkdir |
| **file** | 열린 파일 인스턴스 | open, read, write, mmap |
| **superblock** | 마운트된 파일 시스템 전체 | 파일 시스템 마운트, inode 조회 |
| **dentry** | 디렉터리 엔트리 (경로 구성요소) | 경로 탐색 캐싱 |

### 객체 지향 설계

각 객체는 **함수 테이블 포인터**를 가진다. VFS는 어떤 파일 시스템인지 모르고 함수 포인터만 호출한다.

```c
struct file_operations {
    int (*open)(...);
    ssize_t (*read)(...);
    ssize_t (*write)(...);
    int (*mmap)(...);
    // ... 각 파일 시스템이 구현
};
```

### 객체 간 관계

<NestedDiagram
  title="superblock — inode — file 관계"
  items={[
    {
      label: "superblock (ext4)",
      highlight: true,
      children: [
        { label: "inode A" },
        { label: "inode B" },
      ],
    },
    {
      label: "열린 파일 (file)",
      children: [
        { label: "P1 → A", highlight: true },
        { label: "P2 → A", highlight: true },
        { label: "P3 → B", highlight: true },
      ],
    },
  ]}
/>

- **inode**: 파일 자체 (하나만 존재) — 소유자, 크기, 수정 시간, 데이터 블록 위치
- **file**: 열린 파일 인스턴스 (여러 개 가능) — 현재 읽기/쓰기 위치, 열기 모드, 프로세스별 상태
- **dentry 캐시**: 경로의 각 구성요소(`/` → `usr` → `include` → `stdio.h`)를 캐싱하여 경로 탐색 속도를 높인다.

### 전체 구조

<LayerStack
  title="VFS 계층 구조"
  layers={[
    { label: "사용자 애플리케이션", description: "open() · read() · write()" },
    { label: "VFS", description: "inode · file · superblock · dentry", highlight: true },
  ]}
/>

<div style="max-width: 480px; margin: 0 auto;">
  <ArchitectureStack
    title="VFS 아래의 파일 시스템 구현체"
    topItems={[
      { label: "ext4" },
      { label: "NFS" },
      { label: "/proc" },
    ]}
    baseLayer={{ label: "VFS 인터페이스", description: "함수 테이블 포인터로 연결", highlight: true }}
  />
</div>

## 예시

VFS는 유니버설 어댑터에 비유할 수 있다. 한국 플러그(ext4), 미국 플러그(FAT32), 유럽 플러그(NFS) 모두 동일한 소켓(VFS)에 연결 가능하다.

`open("/home/user/file.txt")` 호출 시:

<StepFlow
  title="open() 호출 흐름"
  steps={[
    { label: "경로 탐색", description: "VFS가 dentry 캐시에서 경로 탐색 (캐시 미스 시 실제 디렉터리 읽기)" },
    { label: "객체 생성", description: "해당 inode 반환 → file 객체 생성" },
    { label: "실제 읽기", description: "read() 호출 → VFS가 file→f_op→read() → ext4의 read 구현 실행" },
  ]}
/>

### 장단점

- **장점**: 파일 시스템 종류와 무관하게 동일한 API 사용 가능, 새로운 파일 시스템 추가가 용이 (함수 테이블만 구현), dentry 캐시로 경로 탐색 성능 향상
- **단점**: 추상화 계층으로 인한 약간의 오버헤드, 특수 파일 시스템의 고유 기능을 VFS로 노출하기 어려울 수 있음
