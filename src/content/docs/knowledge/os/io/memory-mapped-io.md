---
title: "Memory-Mapped I/O"
description: "장치 컨트롤러의 레지스터를 CPU의 메모리 주소 공간에 매핑하여 일반 메모리 접근 명령어로 I/O를 수행하는 방식"
tags: ["OS", "I/O", "Memory"]
created: 2026-01-23
updated: 2026-01-27
slug: knowledge/os/memory-mapped-io
sidebar:
  order: 4
---

## 핵심 개념

장치 컨트롤러의 레지스터를 CPU의 메모리 주소 공간에 매핑하여, 일반 메모리 접근 명령어로 I/O를 수행하는 방식이다. 별도의 I/O 명령어(IN, OUT) 없이 표준 데이터 전송 명령어(load/store)로 장치를 제어할 수 있다.

## 동작 원리

1. 장치 컨트롤러의 레지스터가 물리 메모리 주소 공간의 특정 영역에 매핑됨
2. CPU는 표준 데이터 전송 명령어(load/store)로 매핑된 주소에 읽기/쓰기
3. 메모리 컨트롤러가 해당 주소가 장치 영역인지 판단
4. 장치 영역이면 요청을 해당 장치 컨트롤러로 전달
5. 장치 컨트롤러가 레지스터 접근을 처리

## 예시

### 전통적 I/O vs Memory-Mapped I/O

```assembly
# 전통적 I/O (Port I/O)
OUT 0x3F8, data    ; 별도의 I/O 명령어 필요

# Memory-Mapped I/O
MOV [0xB8000], data  ; 일반 메모리 명령어로 I/O 수행
```

### 그래픽 메모리 예시

그래픽 메모리에 화면 데이터를 직접 쓰면, 그래픽 컨트롤러가 해당 내용을 읽어 모니터에 표시한다. 수백만 바이트의 그래픽 데이터를 메모리 쓰기로 빠르게 전송할 수 있다.

## 장단점

### 장점

- 일반 메모리 명령어 사용 가능 → 프로그래밍 단순화
- 대량 데이터 전송 시 I/O 명령어보다 빠름
- 기존 메모리 접근 최적화(캐시 등) 활용 가능

### 단점

- 메모리 주소 공간의 일부를 장치가 점유 → 사용 가능한 메모리 감소
- 캐시 일관성 문제 발생 가능 (장치 레지스터는 캐시하면 안 됨)
- 메모리 보호 메커니즘으로 접근 제어 필요
