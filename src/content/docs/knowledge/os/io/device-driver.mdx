---
title: "디바이스 드라이버"
description: "특정 장치 컨트롤러의 차이를 추상화하여 커널 I/O 서브시스템에 표준화된 인터페이스를 제공하는 커널 모듈"
tags: ["OS", "I/O", "Device", "Driver", "Kernel"]
created: 2026-01-23
updated: 2026-01-27
draft: false
slug: knowledge/os/device-driver
sidebar:
  order: 8
---

import LayerStack from '../../../../../components/LayerStack.astro';
import StepFlow from '../../../../../components/StepFlow.astro';
import ArchitectureStack from '../../../../../components/ArchitectureStack.astro';

## 핵심 개념

디바이스 드라이버는 다양한 I/O 장치들의 제어 방식 차이를 숨기고, 커널 I/O 서브시스템에 통일된 인터페이스(read, write, open, close 등)를 제공하는 커널 모듈이다. 새로운 장치가 추가될 때마다 OS를 재작성할 필요 없이, 해당 장치용 드라이버만 작성하면 된다.

## 동작 원리

### 계층 구조

<LayerStack
  title="I/O 요청 흐름"
  layers={[
    { label: "Application", description: "system call: read/write" },
    { label: "Kernel I/O Subsystem", description: "표준 인터페이스" },
    { label: "Device Driver", description: "keyboard / disk / network 등", highlight: true },
    { label: "Device Controller" },
    { label: "Physical Device" },
  ]}
/>

### 드라이버 추상화

<div style="max-width: 480px; margin: 0 auto;">
  <ArchitectureStack
    title="여러 드라이버가 통일된 인터페이스 위에서 동작"
    topItems={[
      { label: "Keyboard Driver" },
      { label: "Disk Driver" },
      { label: "Network Driver" },
    ]}
    baseLayer={{ label: "Kernel I/O Subsystem", description: "read · write · open · close", highlight: true }}
  />
</div>

### 작동 메커니즘

<StepFlow
  title="I/O 요청 처리 흐름"
  steps={[
    { label: "인터페이스 정의", description: "커널 I/O 서브시스템이 표준 인터페이스 정의" },
    { label: "드라이버 구현", description: "각 장치 드라이버가 해당 장치에 맞게 인터페이스 구현" },
    { label: "시스템 콜", description: "애플리케이션이 통일된 시스템 콜로 I/O 수행" },
    { label: "요청 전달", description: "커널이 적절한 드라이버로 요청 전달" },
  ]}
/>

### 장치 분류

| 분류 기준 | 유형 | 예시 |
|----------|------|------|
| 데이터 전송 모드 | 블록/문자 | 디스크/터미널 |
| 접근 방식 | 순차/랜덤 | 모뎀/CD-ROM |
| 전송 스케줄 | 동기/비동기 | 테이프/키보드 |
| 공유 | 전용/공유 | 테이프/키보드 |

## 예시

USB 키보드와 PS/2 키보드는 내부적으로 다르게 동작하지만, 둘 다 같은 키보드 드라이버 인터페이스를 통해 OS에 문자 입력을 전달한다. 사용자 프로그램은 어떤 종류의 키보드인지 알 필요 없이 동일한 방식으로 키 입력을 받을 수 있다.

## 트레이드오프

**장점:**
- 장치 독립성: 애플리케이션이 장치 세부사항을 몰라도 됨
- 확장성: 새 장치 추가 시 드라이버만 작성하면 됨
- 유지보수: 드라이버만 수정하면 장치 지원 가능

**단점:**
- 추상화 오버헤드: 드라이버 계층 통과 비용
- 드라이버 품질: 버그가 있는 드라이버는 시스템 불안정 유발
- OS별 별도 개발: Windows, Linux 등 각 OS용 드라이버 필요
