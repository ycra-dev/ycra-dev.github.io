---
title: "버퍼링 (Buffering)"
description: "두 장치 또는 장치와 애플리케이션 간 데이터 전송 시 속도/크기 차이를 해소하기 위해 사용하는 임시 메모리 영역"
tags: ["OS", "I/O", "Performance"]
created: 2026-01-23
updated: 2026-01-27
slug: knowledge/os/buffering
sidebar:
  order: 6
---

import StepFlow from '../../../../../components/StepFlow.astro';

## 핵심 개념

버퍼링은 생산자-소비자 간 속도 불일치, 장치 간 데이터 전송 크기 불일치, Copy semantics 보장을 위해 사용하는 임시 메모리 영역이다. I/O 장치들의 속도 차이는 수백~수천 배에 달하므로, 버퍼를 통해 빠른 쪽과 느린 쪽을 분리한다.

## 동작 원리

### 1. 속도 불일치 해소 (Speed Mismatch)

빠른 쪽이 버퍼에 데이터를 채우고, 느린 쪽이 자신의 속도로 소비한다.

**Double Buffering**: 두 개의 버퍼를 번갈아 사용

<StepFlow
  title="Double Buffering 흐름"
  cycle={true}
  steps={[
    { label: "Buffer 1 쓰기", description: "Network → Buffer 1 쓰기 / Disk ← Buffer 2 읽기" },
    { label: "역할 교대", description: "두 버퍼의 역할을 스왑" },
    { label: "Buffer 2 쓰기", description: "Network → Buffer 2 쓰기 / Disk ← Buffer 1 읽기" },
    { label: "역할 교대", description: "두 버퍼의 역할을 스왑" }
  ]}
/>

### 2. 크기 불일치 해소 (Size Mismatch)

네트워크 패킷은 작고, 디스크 블록은 크기 때문에 버퍼에서 fragmentation/reassembly를 수행하여 여러 패킷을 모아 하나의 디스크 블록으로 만든다.

### 3. Copy Semantics 보장

애플리케이션이 write() 호출 후 버퍼 내용을 변경해도 원래 데이터가 디스크에 기록되어야 한다. 커널이 애플리케이션 데이터를 커널 버퍼로 복사하여 보장한다.

## Buffer vs Cache

| 구분 | Buffer | Cache |
|------|--------|-------|
| 목적 | 속도/크기 차이 해소 | 빠른 재접근 |
| 데이터 | 유일한 복사본일 수 있음 | 항상 다른 곳에 원본 존재 |
| 사용 패턴 | 한 번 쓰고 비움 | 여러 번 읽기 |

## 예시

인터넷에서 파일 다운로드 시, 네트워크 속도는 가변적이지만 버퍼 덕분에 디스크는 일정한 크기의 블록을 효율적으로 기록할 수 있다. 마치 공장의 컨베이어 벨트 사이 적재 공간처럼, 빠른 기계가 물건을 쌓아두면 느린 기계가 자기 속도로 가져간다.

## 장단점

**장점**:
- 생산자-소비자 결합도 감소 (decoupling)
- 비동기 I/O 가능
- 대역폭 효율 향상

**단점**:
- 메모리 사용량 증가
- 데이터 복사 오버헤드
- 버퍼 overflow 시 데이터 손실 가능
