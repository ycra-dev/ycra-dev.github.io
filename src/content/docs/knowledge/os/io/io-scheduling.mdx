---
title: "I/O 스케줄링 (I/O Scheduling)"
description: "대기 중인 I/O 요청들의 실행 순서를 재배치하여 시스템 효율성과 응답 시간을 개선하는 기법"
tags: ["OS", "I/O", "Scheduling"]
created: 2026-01-23
updated: 2026-01-27
slug: knowledge/os/io-scheduling
sidebar:
  order: 9
---

import StepFlow from '../../../../../components/StepFlow.astro';

## 핵심 개념

I/O 스케줄링은 대기 중인 I/O 요청들의 실행 순서를 재배치하여 시스템 효율성과 응답 시간을 개선하는 기법이다. 디스크 같은 기계식 장치는 요청 순서에 따라 성능 차이가 매우 크기 때문에(seek time) 스케줄링이 중요하다.

## 동작 원리

<StepFlow
  title="I/O 스케줄링 처리 흐름"
  steps={[
    { label: "대기 큐 유지", description: "각 장치마다 대기 큐(wait queue) 유지" },
    { label: "요청 추가", description: "애플리케이션이 blocking I/O 호출 시 요청이 큐에 추가" },
    { label: "요청 재배치", description: "I/O 스케줄러가 큐의 요청들을 재배치" },
    { label: "장치 전달", description: "효율적인 순서로 장치에 전달" },
  ]}
/>

스케줄링 시 고려 사항:
- 전체 시스템 효율성
- 프로세스 간 공정성 (fairness)
- 평균 응답 시간 최소화
- 우선순위 (예: 가상 메모리 요청 > 일반 애플리케이션)

## 예시

디스크 암이 블록 50에 있을 때, App1(블록 900), App2(블록 100), App3(블록 500) 순서로 요청이 들어온다고 하자.

| 방식 | 처리 순서 | 총 헤드 이동 |
|------|----------|-------------|
| 원래 순서 (FCFS) | 50 → 900 → 100 → 500 | 2,150 |
| 스케줄링 후 | 50 → 100 → 500 → 900 | 850 |

엘리베이터가 요청 순서(5층→1층→3층)가 아닌 위치 순서(1층→3층→5층)로 이동하면 효율적인 것과 같다.

### Device-Status Table

| 장치 | 상태 | 대기 요청 |
|------|------|----------|
| keyboard | idle | - |
| laser printer | busy | 주소: 38546, 길이: 1372 |
| disk unit 2 | busy | file:xxx read 43046, file:yyy write 03458 |

커널이 이 테이블을 관리하여 장치 상태와 대기 요청을 추적한다.

## 디스크 스케줄링 알고리즘

HDD는 헤드 이동(탐색)이 느리므로, 요청 순서를 최적화하면 총 탐색 거리를 줄여 성능을 향상시킬 수 있다.

### FCFS (First-Come, First-Served)

요청 도착 순서대로 처리한다. 구현이 간단하고 공정하지만 탐색 거리 최적화가 없다.

### SCAN (Elevator Algorithm)

헤드가 한 방향으로 끝까지 이동하며 요청을 처리하고, 끝에서 방향을 반전한다. FCFS보다 탐색 거리가 감소하며 기아가 없다.

### C-SCAN (Circular SCAN)

한 방향으로만 요청을 처리한다. 끝에 도달하면 반대쪽 끝으로 즉시 이동(서비스 안 함)하여 다시 같은 방향으로 처리한다. SCAN보다 균일한 대기 시간을 제공한다.

| 알고리즘 | 헤드 이동 방향 | 서비스 방식 |
|----------|--------------|------------|
| SCAN | 양방향 왕복 | 양쪽 끝까지 이동하며 양방향 모두 서비스 |
| C-SCAN | 단방향 순환 | 한 방향으로만 서비스, 끝 도달 시 시작점으로 복귀 |

### NOOP (No Operation)

요청 순서를 재배치하지 않고, 인접한 요청만 병합(merge)하여 처리한다. 탐색 최적화를 하지 않으므로 CPU 오버헤드가 가장 적다.

SSD/NVMe처럼 탐색 시간이 없는 장치에서는 헤드 이동 최적화가 무의미하므로, 복잡한 정렬 없이 병합만 수행하는 NOOP이 적합하다. 반대로 HDD에서는 탐색 거리 최적화가 없어 성능이 떨어진다.

| 알고리즘 | 요청 재배치 | 인접 요청 병합 |
|----------|-----------|--------------|
| FCFS | X | X |
| NOOP | X | O |
| SCAN | O | O |

### Linux 스케줄러

| 스케줄러 | 설명 | 적합 환경 |
|----------|------|-----------|
| **Deadline** | 읽기/쓰기 큐 분리, LBA 순 정렬, 500ms 기아 방지 | 범용 |
| **NOOP** | FCFS + 인접 요청 병합, 최소 CPU 사용 | SSD, NVMe |
| **CFQ** | 프로세스별 공정 큐, 실시간/일반/유휴 우선순위 | 데스크톱 HDD |

### NVM 스케줄링

SSD는 탐색 시간이 없으므로 스케줄링 이득이 적다. 보통 FCFS 또는 NOOP을 사용하며, 인접 쓰기 요청만 병합한다.
