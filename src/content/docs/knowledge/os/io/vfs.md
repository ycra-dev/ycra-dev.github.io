---
title: "VFS (Virtual File System)"
description: "다양한 파일 시스템을 단일 인터페이스로 추상화하여 애플리케이션이 파일 시스템 종류와 무관하게 동일한 시스템 콜을 사용할 수 있게 하는 계층"
tags: ["OS", "FileSystem", "Linux"]
created: 2026-01-28
updated: 2026-01-28
draft: false
slug: knowledge/os/vfs
sidebar:
  order: 12
---

## 핵심 개념

VFS(Virtual File System)는 ext4, NFS, FAT32, /proc 등 **다양한 파일 시스템을 단일 인터페이스로 추상화**하는 계층이다. 애플리케이션은 파일 시스템 종류와 무관하게 동일한 `open()`, `read()`, `write()` 시스템 콜을 사용할 수 있다.

UNIX 철학에서 "모든 것은 파일"이다. 디스크 파일뿐 아니라 디바이스, 네트워크, 프로세스 정보까지 파일처럼 다루려면 이러한 공통 추상화 계층이 필요하다.

## 동작 원리

### 4가지 핵심 객체 타입

VFS는 모든 파일 시스템을 4가지 객체 타입으로 추상화한다.

| 객체 | 설명 | 주요 연산 |
|------|------|----------|
| **inode** | 개별 파일의 메타데이터 | create, link, unlink, mkdir |
| **file** | 열린 파일 인스턴스 | open, read, write, mmap |
| **superblock** | 마운트된 파일 시스템 전체 | 파일 시스템 마운트, inode 조회 |
| **dentry** | 디렉터리 엔트리 (경로 구성요소) | 경로 탐색 캐싱 |

### 객체 지향 설계

각 객체는 **함수 테이블 포인터**를 가진다. VFS는 어떤 파일 시스템인지 모르고 함수 포인터만 호출한다.

```c
struct file_operations {
    int (*open)(...);
    ssize_t (*read)(...);
    ssize_t (*write)(...);
    int (*mmap)(...);
    // ... 각 파일 시스템이 구현
};
```

### 객체 간 관계

```
superblock (ext4 파일 시스템)
    │
    ├── inode (파일 A) ←── file (프로세스 1이 열음)
    │                  ←── file (프로세스 2도 열음)
    │
    └── inode (파일 B) ←── file (프로세스 3이 열음)

dentry 캐시: /usr/include/stdio.h
    "/" → "usr" → "include" → "stdio.h" (각각 dentry 객체)
```

- **inode**: 파일 자체 (하나만 존재) — 소유자, 크기, 수정 시간, 데이터 블록 위치
- **file**: 열린 파일 인스턴스 (여러 개 가능) — 현재 읽기/쓰기 위치, 열기 모드, 프로세스별 상태

### 전체 구조

```
┌─────────────────────────────────────────────┐
│              사용자 애플리케이션              │
│         open(), read(), write(), ...        │
├─────────────────────────────────────────────┤
│                    VFS                       │
│  ┌─────────┬─────────┬─────────┬─────────┐  │
│  │ inode   │  file   │superblk │ dentry  │  │
│  └────┬────┴────┬────┴────┬────┴────┬────┘  │
├───────┼─────────┼─────────┼─────────┼───────┤
│       ↓         ↓         ↓         ↓       │
│  ┌─────────────────────────────────────┐    │
│  │    ext4    │   NFS   │   /proc     │    │
│  └─────────────────────────────────────┘    │
└─────────────────────────────────────────────┘
```

## 예시

VFS는 유니버설 어댑터에 비유할 수 있다. 한국 플러그(ext4), 미국 플러그(FAT32), 유럽 플러그(NFS) 모두 동일한 소켓(VFS)에 연결 가능하다.

`open("/home/user/file.txt")` 호출 시:

1. VFS가 dentry 캐시에서 경로 탐색 (캐시 미스 시 실제 디렉터리 읽기)
2. 해당 inode 반환 → file 객체 생성
3. `read()` 호출 → VFS가 `file->f_op->read()` 호출 → ext4의 read 구현 실행

### 장단점

- **장점**: 파일 시스템 종류와 무관하게 동일한 API 사용 가능, 새로운 파일 시스템 추가가 용이 (함수 테이블만 구현), dentry 캐시로 경로 탐색 성능 향상
- **단점**: 추상화 계층으로 인한 약간의 오버헤드, 특수 파일 시스템의 고유 기능을 VFS로 노출하기 어려울 수 있음

## 관련 개념

- [UNIX 아이노드 (Inode)](/knowledge/os/unix-inode/) - VFS가 추상화하는 핵심 객체
- [UNIX 파일 디스크립터 (File Descriptor)](/knowledge/os/unix-file-descriptor/) - 열린 파일을 참조하는 정수 핸들
- [저널링 파일 시스템 (Journaling)](/knowledge/os/journaling/) - VFS 아래 구체적 파일 시스템 구현
