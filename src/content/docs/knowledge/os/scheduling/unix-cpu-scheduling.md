---
title: "UNIX CPU 스케줄링"
description: "동적 우선순위 기반 알고리즘으로, CPU 사용량에 따라 우선순위를 조정하여 대화형 프로세스를 우대하는 스케줄링"
tags: ["OS", "Process", "Scheduling", "CPU"]
created: 2026-01-23
updated: 2026-01-27
draft: false
slug: knowledge/os/unix-cpu-scheduling
sidebar:
  order: 14
---

## 핵심 개념

UNIX CPU 스케줄링은 동적 우선순위 기반 알고리즘으로, CPU 사용량에 따라 우선순위를 조정하여 대화형 프로세스를 우대합니다. 단순 라운드로빈은 CPU 집중 작업과 대화형 작업을 구분하지 못하기 때문에, 시분할 시스템에서 대화형 프로세스의 응답 시간을 빠르게 유지하면서 CPU 집중 작업도 공정하게 처리하는 것이 목표입니다.

## 동작 원리

우선순위 값이 클수록 낮은 우선순위입니다 (양수는 사용자, 음수/"pzero" 이하는 시스템).

- **타임 슬라이스**: FreeBSD는 0.1초마다 재스케줄링
- **우선순위 재계산**: 1초마다 모든 프로세스의 우선순위 재계산
- **음의 피드백(negative feedback)**: CPU를 많이 사용할수록 우선순위 낮아짐 (더 양수)
  - 대화형(I/O 바운드) 프로세스는 자주 sleep하므로 CPU 누적량 적음 → 높은 우선순위 유지
  - CPU 바운드 프로세스는 누적량 증가 → 우선순위 하락
- **nice 값**: 사용자가 자발적으로 우선순위 낮출 수 있음
- **sleep/wakeup**: 이벤트 대기 시 `sleep()` 호출, 이벤트 발생 시 `wakeup()`으로 ready queue 이동

```
우선순위 계산 (간략화):
priority = base_priority + (recent_cpu_usage / 4) + (2 * nice)

┌───────────────────────────────────────────┐
│ 우선순위 범위                              │
├───────────────────────────────────────────┤
│ < pzero : 시스템 프로세스 (시그널 무시)     │
│ = pzero : 경계                             │
│ > pzero : 사용자 프로세스 (시그널 가능)     │
└───────────────────────────────────────────┘

Ready Queue (우선순위별):
[높은] ←─ 대화형 프로세스
[중간]
[낮은] ←─ CPU 집중 프로세스, nice된 프로세스
```

## 예시

스케줄링은 "식당 대기열"과 같습니다. 오래 먹은 손님(CPU 많이 사용)은 뒤로 밀리고, 막 들어온 손님(대화형)이 먼저 서비스 받습니다.

```
시간 t=0: 프로세스 A(편집기), B(컴파일러) 시작

t=1초:
  A: 주로 키 입력 대기 (sleep) → CPU 누적 낮음 → 높은 우선순위
  B: 계속 계산 → CPU 누적 높음 → 낮은 우선순위

t=2초:
  사용자가 키 입력 → A 즉시 실행 (높은 우선순위)
  B는 A 완료 후 실행
```

- 대화형 프로세스 응답 시간 우수
- 음의 피드백으로 기아 방지 (CPU 바운드도 결국 실행됨)
- 단점: 커널 내 선점 없음, 멀티프로세서 확장 어려움, 실시간 보장 없음

## 관련 개념

- [UNIX 프로세스 모델](/knowledge/os/unix-process-model/)
- [멀티태스킹 (Multitasking)](/knowledge/os/multitasking/)
- [BSD 디맨드 페이징 (Demand Paging)](/knowledge/os/demand-paging/)
