---
title: "2026-02-06 (금)"
description: "OS I/O 서브시스템 노트를 mdx 포맷으로 마이그레이션하며 I/O 전반 정독"
tags: ["TIL", "OS", "I/O", "FileSystem"]
created: 2026-02-06
updated: 2026-02-06
slug: til/2026-02-06
sidebar:
  order: 6
---

## 오늘 한 것

- OS I/O 관련 Knowledge 노트들을 `.md`에서 `.mdx` 포맷으로 전환
- 총 19개 파일 수정 (616 추가, 661 삭제)
- 변환 대상 노트:
  - Buffering, Spooling
  - Device Driver, Interrupt-Driven I/O
  - I/O Scheduling
  - UNIX Block Buffer Cache, UNIX File Descriptor
  - VFS (Virtual File System)
  - Windows I/O Manager & IRP
- `.md`로 유지한 노트들(Polling, Memory-Mapped I/O, Blocking/Non-blocking I/O)도 문체 통일(습니다체 → 이다체) 및 불필요한 관련 개념 섹션 제거

## 주요 작업 내용

### MDX 포맷 전환

- 텍스트 기반 ASCII 다이어그램을 Astro 컴포넌트(`StepFlow`, `LayerStack`, `ArchitectureStack`, `NestedDiagram`)로 교체
- 구조화된 시각 자료로 개념 전달력 향상
- 관련 개념 링크 섹션 제거 (사이드바 네비게이션으로 대체)

## 배운 것

### I/O 하드웨어 제어 방식의 스펙트럼

세 가지 방식이 CPU 관여도와 효율성에서 트레이드오프를 이룬다:

- **Polling**: CPU가 상태 레지스터를 반복 확인 (busy-waiting). 구현 단순하지만 CPU 낭비
- **Interrupt-Driven I/O**: 장치가 완료 시 CPU에 인터럽트 발생. CPU 활용도 향상, 단 인터럽트 처리 오버헤드 존재
- **Memory-Mapped I/O**: 장치 레지스터를 메모리 주소 공간에 매핑하여 load/store 명령어로 I/O 수행

핵심 통찰: 장치가 빠르면 폴링이, 느리면 인터럽트가 유리하다. 고처리량 네트워크 카드는 하이브리드 전략(인터럽트로 시작 → 폴링으로 전환)을 사용한다.

### 버퍼링과 스풀링

- **Buffer**: 메모리에서 속도/크기 차이 해소. Double Buffering으로 생산자-소비자 분리
- **Spooling**: 디스크를 거대한 버퍼로 사용하여 전용 장치 접근을 직렬화. 멀티프로그래밍의 도입 기반이 됨
- **Buffer vs Cache**: Buffer는 유일한 복사본일 수 있고 한 번 쓰고 비우지만, Cache는 항상 원본이 존재하고 여러 번 읽기용

### 디바이스 드라이버와 추상화 계층

- 커널 I/O 서브시스템이 표준 인터페이스를 정의하고, 각 드라이버가 이를 구현하는 구조
- 장치 분류: 블록/문자, 순차/랜덤, 동기/비동기, 전용/공유

### I/O 스케줄링

- FCFS → SCAN(엘리베이터) → C-SCAN(단방향 순환)으로 발전
- **NOOP**: 재배치 없이 인접 요청만 병합. SSD/NVMe처럼 탐색 시간이 없는 장치에 적합
- Linux 스케줄러: Deadline(범용), NOOP(SSD), CFQ(데스크톱 HDD)

### UNIX I/O 구조

**파일 디스크립터 (fd)**
- 프로세스별 fd 테이블 → 시스템 전역 file 테이블 → in-core inode 테이블의 3단계 참조 체인
- `fork()` 시 자식이 부모의 fd 테이블을 복사하여 같은 file 구조체(오프셋)를 공유

**블록 버퍼 캐시**
- 해시 테이블 + LRU/AGE/EMPTY 리스트로 구성
- Write-back 방식: 캐시에 쓰고 dirty 표시, `sync()`로 30초마다 flush
- 시스템 크래시 시 dirty 버퍼 손실 위험이라는 트레이드오프

**VFS (Virtual File System)**
- 4가지 핵심 객체: inode, file, superblock, dentry
- 객체 지향 설계: 각 객체가 함수 테이블 포인터를 가지고, VFS는 파일 시스템을 모른 채 함수 포인터만 호출
- "모든 것은 파일" 철학의 구현체

### Windows I/O 구조

- **IRP (I/O Request Packet)**: 모든 I/O 요청을 패킷으로 변환하여 드라이버 스택을 따라 전달
- 비동기 완료: DMA 완료 → ISR → DPC 큐잉 → APC 또는 I/O Completion Port로 앱에 통지
- UNIX의 VFS와 대비되는 Windows만의 계층적 드라이버 스택 모델

### Blocking vs Non-blocking I/O

| 구분 | Blocking | Non-blocking | Asynchronous |
|------|----------|--------------|--------------|
| 반환 시점 | I/O 완료 후 | 즉시 | 즉시 |
| 반환값 | 전체 데이터 | 가능한 만큼 | 없음 (나중에 통보) |
| 완료 통보 | 필요 없음 | 직접 확인 | 시그널/콜백 |
